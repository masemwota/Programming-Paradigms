object functional {
  println("Welcome to the Scala worksheet")
  
	  /**
	  * PROBLEM 1
	  */
		def compose[T] (f: T => T, g: T =>T): T=>T =
		{
		   def r(x: T): T = f(g(x));
		   r _
		}
		
		/**
		* PROBLEM 2
		* Self-composition iterator combinator
		*/
		
		//def selfIter[T](f: T=>T, n: Int) = f composed with itself n times.
		def id[T](x: T): T = x
		
		def selfIter[T] (f: T => T, n: Int): T => T =
		{
				if(n == 0) id _
				else if(n == 1) f
				else selfIter(compose(f, f) , n-1)
		}
		
		def inc(x: Double) = x + 1
	
		 
		selfIter(inc, 0) (10)
		selfIter(inc, 2) (4)
		selfIter(inc, 4) (5)
		selfIter(inc, 5) (5)
		
		
		def double(x: Double) = 2 * x
		
		selfIter(double, 0) (2)
		selfIter(double, 2) (2)
		selfIter(double, 2) (3)
		selfIter(double, 3) (2)
		selfIter(double, 3) (3)
		selfIter(double, 4) (1)
		
		
		/**
		*	PROBLEM 3
		* Counts elements
		*/
		
		//Write a function called countPass that counts the number of elements in an array of elements of type T that pass a test of type T=>Boolean.
		//make it recursive
		def countPass[T](vals: Array[T], test: T => Boolean): Int =
		{
				0
		}
		
		def odd(n: Int) = n % 2 != 0
		def pal(n: String) = (n == n.reverse)
		countPass(Array(1,2,3,4,5), odd)
		countPass(Array("mom", "dad", "dog" "bro"), pal)
		
		
		/**
		* 	PROBLEM 4
		* Recur combinator
		*/
		
		def makeIter(baseVal: Int, combine: (Int, Int) => Int): Int => Int =
		{
				def f(n: Int): Int =
				{
						var result = baseVal
						for(count <- 1 to n)
							result = combine(count, result)
						result
				}
				f _
		}
		
		//iterative factorial
		def f(n: Int) =
		{
			var result = 1
			for(count <- 1 to n)
				result = count * result
			result
		}
		
		
		//triangle function -- iterative summation
		def trian(n: Int) =
		{
			var result = 0
			for(count <- 1 to n)
				result = count + result
			result
		}
		
		val fact = makeIter(1, _*_)
		
		fact(5)
		fact(4)
		
		val tri = makeIter(0, (n: Int, m: Int) => n + m)
		
		tri(5)
		tri(4)
		
		
		
		/*
		def recur(baseVal: Int, combine: (Int, Int) => Int): Int => Int =
		{
				//
		}
		*/
		
		/**
		*	PROBLEM 5
		* De-Optionize
		*/
		
		def sqrt(x: Double): Option[Double] =
		if (x < 0) None else Some(math.sqrt(x))
		
		sqrt(100)
		sqrt(-100)
		
		def sqrt2(x: Double): Double =
			sqrt(x) match
			{
				case None => throw new Exception("bad input")
				case Some(result) => result
			}
			
		try {
			println(sqrt2(100))
			println(sqrt2(-100))
		} catch {
				case e: Exception => println(e)
		}
		
		//the code
		
		def deOptionize[S,T](f: S => Option[T]): S => T = 
		{
		
		}
		
		
}